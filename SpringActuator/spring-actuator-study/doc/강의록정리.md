<style>
.burk {
    background-color: red;
    color: yellow;
    display:inline-block;
}
</style>


# spring boot actuator 파헤치기
[인프런 강의 바로 가기](https://www.inflearn.com/course/spring-boot-actuator-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0/dashboard)

[강의자료_tistory](https://semtul79.tistory.com)

섹션 1. 실습 프로젝트 생성 및 강의 개요 3개 ∙ (19분)
- 프로젝트 생성 08:00
- 공식 가이드 페이지, 의존성 라이브러리 11:13
- 강의 자료

섹션 2. actuator 기본 설정과 다양한 endpoint 4개 ∙ (2시간 14분)
- endpoints 설정 25:48
- custom endpoint 생성 35:40
- health endpoint 25:34
- info endpoint 47:36

섹션 3. metrics endpoint 8개 ∙ (2시간 28분)
- metrics endpoint 개요  26:35
- Counter 37:37
- metrics tags #1 17:25
- metrics tags #2 10:24
- Gauge 14:24
- Timer #1 19:16
- Timer #2 16:10
- Metrics 정리 06:38

섹션 4. spring boot admin 연동 2개 ∙ (23분)
- spring boot admin 연동 19:49
- spring boot admin 연동 #2 03:34

섹션 5. 마무리 1개 ∙ (2분)
- 마무리 02:54

## 섹션 1. 실습 프로젝트 생성 및 강의 개요
### 1.  프로젝트 생성
spring boot 3.x 기반으로 actuator 설정 및 custom metrics 추가하는 방법
- 단순히 actuator 사용법만 익히는 것이 아닌, spring boot 내 spring boot 3.x 기반으로 actuator 설정 및 custom metrics 추가하는 방법

- [강의 URL-인프런](https://www.inflearn.com/course/spring-boot-actuator-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0)

- [유프브_동영상링크](https://youtu.be/2-JXZOJkkrM)

#### project 생성

https://start.spring.io/ 에서 프로젝트를 하나 생성

- 현 시점 최신 버전인 3.0.4 를 선택
- spring boot 3.0 부터는 java 17이 최소버전

의존성에는 
- spring boot actuator 가 필수이며, 
- WEB
- H2


구동
- http://127.0.0.1:8080/actuator

- self -> http://127.0.0.1:8080/actuator
- health -> http://127.0.0.1:8080/actuator/health
- health-path -> http://127.0.0.1:8080/actuator/health/{*path}

HATEOAS
- . 발음은 / 헤이티오스/ 

### 2. 공식 가이드 페이지, 의존성 라이브러리
Hello World Study 2023. 3. 20. 23:26 

spring boot actuator 공식 레퍼런스 주소
- https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator


```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>

```
intellij 의 maven 의존성 부분을 보니 
- spring-boot-starter-actuator 는 내부적으로 micrometer 라이브러리를 사용하고, auto configuration을 위한 라이브러리리(spring-boot-actuator-autoconfigure)를 포함하는걸 알 수 있습니다. 

- ![](images/d94675cb.png)

- 핵심 라이브러리인 micrometer-core 의 내용을 살펴보면
  - spring boot 가 구동되는 application 의 health, info, metric 정보들을 수집하는 역할을 하는 binder 클래스들이 아주 많이 구현되어 있는걸 알수 있습니다.


 ### 3. endpoints 설정

https://youtu.be/Ap_vrMyvya8

endpoint
- 정보를 얻을수 있는 링크. 정확히는 url 을 actuator 에서는 endpoint 라고 부릅니다.
- 즉 http://localhost:8080/actuator/health <-- 이런 url 이 각각 endpoint 가 됩니다.

#### 기본 제공되는 endpoints

아래에 주요 endpoint

| 이름|적요|
| :---- | :----------------|
|beans	|등록된 bean 목록 제공 |
|caches	|cache 사용중이라면 cache 관련 정보 제공 |
|conditions	|spring auto configuration 에 의해 bean으로 등록된것과 그렇지 않은 것의 상세 이유를 제공|
|health	|application이 구동중인지, application과 연동되는 다른 서비스(DB, message queue)가 구동중인지 여부 제공|
|info	|application 의 대략적인 정보|
|metrics	|cpu, mem, thread count 등의 모니터링용 메트릭 정보|
|logger	|로거 설정 확인 실시간 로그 레벨 변경 제공 |
|quartz	|quartz 라는 스케줄링 관련 라이브러리를 사용하고 있다면, quartz 관련 정보를 상세히 제공|



더 자세한것은 아래 링크
- https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints


#### endpoint 활성화설정, 노출 설정

endpoint 는 enable/disable (활성화 여부)과 expose ( 노출 여부 ) 라는 2가지 설정을 할 수 있으며 2가지 모두 켜진 상태여야 외부로 노출
- 즉 enable/disable 을 통해 spring boot 내부적으로 특정 endpoint 의 정보를 수집하는걸 설정할 수 있으며,
- expose 설정을 통해 최종적으로 web 이나 jmx ( = java 모니터링 관련 프로토콜/스펙) 에 해당 정보가 보이는걸(=노출) 설정

- default 설정으로 활성화된 endpoint 는 shutdown 이라는 endpoint 를 제외하고 모두 활성화

특정 endpoint 를 enable / disable 하는 방법은
- application.yml 에서 아래처럼 managment.endpoint 하위에 
- endpoint 명을 적고 enabled 에 true, false 를 지정

```yaml
management:
  endpoint:
    shutdown:
      enabled: true
    beans:
      enabled: false
    loggers:
      enabled: true
    quartz:
      enabled: false
```

spring boot assistent
- intellij 에서 spring boot assistent 라는 플러그인을 설치하면 yml 파일에 대해 자동 완성이 지원
- 철자 하나하나 외우지 않아도 쉽게 설정이 가능
- management.endpoint 도 있고 management.endpoints 도 있다

노출(expose) 설정
- 아래처럼 default 로 web과 jmx 에 대해 health 라는 endpoint 만 노출되도록 되어 있습니다.
- include는 노출에 포함할 endpoint,
- exclude 는 노출에 제외할 endpoint 라는 뜻입니다.


https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.exposing

노출방법은
- management.endpoints.web.exposure 하위에 include 와 exclude 에 endpoint 를 적어주면 됩니다.
```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
        exclude: logger
```


활성화/비활성화, 노출 여부도 설정을 했으니 spring boot 재구동을 해봅시다.

- shutdown endpoint 를 명시적으로 enable 시켰기에 shutdown 항목도 보입니다. 
- logger, caches 는 노출 제외 시켰으므로 나오지 않습니다.

- auditevents 라는 endpoint 는 AuditEventRepository 타입의 bean이 등록되어 있어야 동작을 한다고 적혀있습니다.

각 endpoint 별 상세 요건은
- https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints 에서 확인하면 됩니다.



주의할 사항은 별표(*)
- yml 에서 * 는 특별한 의미를 가지기에 * 라고 적으면 안되고 "*" 와 같이 따옴표로 묶어줘야 에러가 나지 않습니다.
- properties 에서는 * 는 특별한 의미가 아닙니다.


#### 보안 문제
actuator 를 통해 application의 다양한 정보를 확인할 수 있고 , 특정 endpoint 에서는 실시간 변경도 가능하게 해줍니다. ( e.g. thread dump )
- 보안상 문제가 있을 수 있으므로 spring security 혹은 이와 유사한 방법으로 보안 위험을 해결하도록 해야합니다.  
- 가장 쉬운 방법은 spring security 를 통해 /actuator url 에 대해 http basic auth 을 적용해서 id, pw 가 맞아야만 pass 되도록 하면 되며, 
- 본 포스팅에서는 security 설정은 다루지 않습니다. 
- ( spring security http basic auth 라고 구글링 하면 많은 정보가 나오니 참고하세요 )


#### endpoint cache
http에 etag 와 같은 캐시 방법이 존재하듯이, endpoint 에도 cache 방법이 있습

endpoint 마다 캐시값을 설정해주고 싶다면 
-  management.endpoint.<endpoint명>.cache.time-to-live 에 작성

time-to-live 는 java.time.Duration 타입
- 1s, 1ms, 10h, 20d 와 같이 값과 단위를 함께
- s -> 초, ms -> 밀리초, h -> 시간, d -> 일

```yaml
management:
  endpoint:
    beans:
      cache:
        time-to-live: 300s
```


#### CORS support
actuator 입장에서의 client 는 일반적으로는 다른 서버
- 간혹 web 화면에서 endpoint 를 호출해야 할 수도 있습
- 이 경우 client 는 web 이 되며, http 요청은 일반적으로 javascript 를 이용할겁니다.
- 웹브라우저에서는 자신의 도메인이 아닌 도메인으로 javascript 가 http 요청을 보내면 CORS 체크를 하게 되며, 서버단에 CORS 허용 설정이 없다면 http 요청이 실패

spring 의 @RestController 를 이용한 클래스라면 @CrossOrigin 어노테이션 한줄 적어주면 끝나는데, 
- actuator 에서도 뭔가 해결책이 있지 않을까요?
- cors 설정을 통해 가능

```yaml
management:
  endpoints:
    web:
      cors:
        allowed-origins: http://test.com
        allowed-methods: GET
```

## 섹션 2. actuator 기본 설정과 다양한 endpoint

### 4. custom endpoint 생성
[유프뷰강의](https://youtu.be/FoC5h1GHkKA)

custom endpoint 를 생성하는 방법

[참고로 공식 가이드는](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.implementing-custom)

이번에 만들 custom endpoint 는
- application에서 참조하는 라이브러리 이름과 버전 정보
- myLibraryInfo 라는 이름의 endpoint

#### 4.1 기본 클래스 만들기
현재 app에서 사용중인 라이브러리들의 이름과 버전정보를 응답으로 리턴하는 custom endpoint 를 만들 필요가 있다고 가정해봅시다.
- getLibraryInfos() 라는 메서드에 라이브러리 정보를 가져와서 list에 저장하고 return 하는 메서드
- 실제 로딩된 라이브러리 정보 가져오는 건 강의 범위에 벗어나므로 하드코딩

```java

@Endpoint(id = "myLibraryInfo")  // endpoint id 지정. 필수!
public class MyLibraryInfoEndpoint {


    @ReadOperation    // read 요청에 대한 메서드라는 의미
    public List<LibraryInfo> getLibraryInfos() {
        // TODO: 라이브러리 정보를 읽어서 name, version을 가져오는 코드가 있어야 하나 하드코딩으로 대체함.
        LibraryInfo libraryInfo1 = new LibraryInfo();
        libraryInfo1.setName("logback");
        libraryInfo1.setVersion("1.0.0");

        LibraryInfo libraryInfo2 = new LibraryInfo();
        libraryInfo2.setName("jackson");
        libraryInfo2.setVersion("2.0.0");

        return Arrays.asList(libraryInfo1, libraryInfo2);
    }
}

```

LibraryInfo ==> DTO

```java
@Data
public class LibraryInfo {
    private String name;
    private String version;
}
```

유심히 봐야 할 부분은 아래 어노테이션입니다.
```{remark}
@Endpoint(id = "myLibraryInfo")
```

rest controller 구현시의  아래 코드 정도의 역할이라고 보면 됩니다.
```java
@RestController
@RequestMapping("/api/myLibraryInfo")
```


@Endpoint 어노테이션에서 중요한 부분
```java
@Target(ElementType.TYPE)   <-- type 즉 클래스 위에 지정 가능한 어노테이션
@Retention(RetentionPolicy.RUNTIME)
public @interface Endpoint {
    String id() default "";       <-- value()가 없고 id()만 있음.
}

```
- @Target
  - ype 으로 적혀있으므로 class 에만 지정이 가능한 어노테이션이며
  - value() 라는 필드가 없고 id() 필드만 존재하는게 특이합니다.
  - @XXX("value1")  <-- 이런식으로 어노테이션을 사용하면 value1 이라는 값이 어노테이션내의 value() 필드에 할당되는게 자바 스펙입니다.

  - @Endpoint 는 value() 필드가 없으므로 @Endpoint("myLibraryInfo") 라고 적으면 오류가 납니다.
  - 반드시 @Endpoint(id = "myLibraryInfo") 와 같이 필드명을 명확히 지정해줘야 합니다.


- @ReadOperation
  - rest controller 구현시 사용하는 아래 어노테이션과 유사
  - 즉 HTTP GET 요청, 즉 읽기 요청


마지막으로 할일은 위 클래스를 bean 으로 등록하면 됩니다.
```java
@Configuration
public class MyLibraryInfoEndpointConfig {

    @Bean
    MyLibraryInfoEndpoint myLibraryInfoEndpoint() {
        return new MyLibraryInfoEndpoint();
    }
}

```
- bean 으로 등록되는 클래스가 우리가 만든 클래스이므로 @Bean 이 아닌 @Component 을 써도 됩니다.
- 즉 위 config 클래스를 삭제하고 아래처럼 @Endpoint 가 붙은 클래스에 @Component 를 적어도 됩니다.
- 그러나 설정관련된 bean 은 일반적으로 @Configuration와 @Bean 을 이용해서 등록하며, spring boot actuator에서도 이 방식으로 endpoint 들을 bean으로 등록해주고 있으므로 가급적 @Bean 을 이용해서 등록하도록 합시다.
```java
@Component    <-- bean 등록을 위해 이걸 추가해도 됨
@Endpoint(id = "myLibraryInfo")
public class MyLibraryInfoEndpoint {
(생략)
}
```

확인
- spring boot 를 재구동한 후 actuator 에 custom endpoint 가 보이는지 확인해봅시다.
- http://127.0.0.1:8080/actuator/myLibraryInfo
- 결과
  ```text
  [
    {
      "name": "logback",
      "version": "1.0.0"
    },
    {
      "name": "jackson",
      "version": "2.0.0"
    }
  ]
  ```

#### 4.2 HTTP Method

thread dump 를 수행하라, logger level 을 debug 나 info 레벨로 변경하라. 와 같이 조회가 아닌 뭔가 수행하라는 명령을 actuator 를 통해 수행할수도 있는데 이때는 HTTP GET 이 적절해보이지 않습니다.

actuator 에서는 이런 문제를 해결하기 위해
- @WriteOperation, @DeleteOperation 이라는 추가 어노테이션이 제공
- ![](images/6c4316b6.png)


#### 4.3 파라미터 수신방법
rest api 의 경우 당연히 파라미터를 수신할 수 있습니다.

spring mvc 에서는 @PathVariable, @RequestParameter, @RequestBody 와 같은 어노테이션을 통해 query string 이나 http body 의 내용을 파라미터로 수신할 수 있습니다.

endpoint 에서도 유사하게 파라미터를 수신하는 방법이 있습니다.



##### 1 - query string으로 수신하는 방법
기존 메서드에 수신하고 싶은 파라미터를 적어주면 됩
- 필수값이 아니라면 @Nullable 을 함께 적어줍니다.
- @ReadOperation 어노테이션이 붙어 있으므로 http GET 요청에 매핑되며, 
- http GET 요청에서 파라미터를 넘기는 기본 방법은 query string
- 아래처럼만 적어줘도 query string 의 값을 매핑시켜서 파라미터로 전달

```java
import org.springframework.boot.actuate.endpoint.annotation.Endpoint;
import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;
import org.springframework.lang.Nullable;

import java.util.Arrays;
import java.util.List;

@Endpoint(id = "myLibraryInfo")
public class MyLibraryInfoEndpoint {
  ...
      if (name != null) {
          resultList = resultList.stream()
                  .filter(libraryInfo -> {
                      return libraryInfo.getName().equals(name);
                  })
                  .toList();
      }
      if (includeVersion == false) {
            resultList = resultList.stream()
                    .map(libraryInfo -> {
                        LibraryInfo simpleInfo = new LibraryInfo();
                        simpleInfo.setName(libraryInfo.getName());
                        // version 정보는 포함하지 않음.
                        return simpleInfo;
                    }).toList();
        }

        return resultList;
    }
}

```
기존 메서드 코드에서 if 문이 2개나 더 들어갔는데, 
- name 으로 필터링 및 includeVersion 의 true, false 에 따라 version 정보를 포함할지를 구현

- http://127.0.0.1:8080/actuator/myLibraryInfo  ==>  400 status 코드가 리턴
  - name과 includeVersion 이라는 파라미터를 적었으며, 
  - includeVersion 파라미터는 @Nullable 이 없으므로 필수 필드인데, 우린 아무런 query string 을 넣지 않았기에 400 bad request 에러를 리턴
- http://127.0.0.1:8080/actuator/myLibraryInfo?includeVersion=true
- http://127.0.0.1:8080/actuator/myLibraryInfo?includeVersion=true&name=jackson


##### 2 - body 수신방법
query string 외에 http body 의 정보를 파라미터로 수신해야 할때도 있습니다. 보통 HTTP POST 방식일때이겠죠.
- 기존 예제와 큰 차이는 없으나, 
- HTTP POST 방식으로 매핑되기 위해 **@WriteOperation** 을 사용해야 하며, 수신하고 싶은 파라미터명을 적어주면 됩니다.

  ```java
  @Slf4j
  @Endpoint(id = "myLibraryInfo")
  public class MyLibraryInfoEndpoint {
  
      @WriteOperation
      public void changeSomething(String name, boolean enableSomething) {
          log.info("name: {}, enableSomething: {}", name, enableSomething);
      }

  }
  ```
- 라이브러리 조회 endpoint 에서는 단순히 로그만 찍어서 파라미터가 잘 수신되는지만 확인

- spring mvc 로 개발시의 body 는 MemberDto, OrderDto 와 같이 DTO 클래스를 파라미터로 지정하는데, 
  - 위 예제에서는 DTO 객체가 아닌, 개별 파라미터를 하나씩 다 적어주는게 특이해 보입니다.
  - **단순한 파라미터 타입만 지원** 
  - DTO와 같이 여러 멤버변수를 가진 객체를 파라미터로 지정해주는건 지원되지 않음
 - spring mvc로 비유하자면, 입력값을 java DTO 타입으로 변환이 안되므로 simple 한 argument resolver 가 지원된다고 볼 수 있습니다.

- HTTP POST 방식으로 요청을 해야하므로 웹브라우저는 사용이 어려우며 
  - postman 이나 insomnia 와 같은 HTTP client 프로그램을 이용해서 테스트를 해야 합니다.
  - insomnia 라는 프로그램을 통해 아래처럼 json type의 body에 name 과 enableSomething 이라는 필드를 넣어줬으며 HTTP POST 로 method 를 지정
  - ![](images/d0c523c8.png)
    - http://127.0.0.1:8080/actuator/myLibraryInfo
      ```json
      {
          "name": "developer",
          "enableSomething": false
      }
      ```

  - java 메서드의 리턴 타입이 void 이므로 별도의 응답 body는 없습
    - 그래서 응답 status 가 204 no content 라고 나오네요.
  - body 의 경우 DTO 로 수신할 수 없는게 다소 불편할 수 있으나, 
    - actuator 에 복잡한 DTO를 넘길일은 거의 없으니 문제는 없어 보입니다.



##### 3 - path 파라미터 수신방법
spring mvc 의 @PathVariable 에 해당하는 path 파라미터 수신
- **@Selector** 라는 path 파라미터 수신용 어노테이션을 사용
- 여기서도 로그를 통해 파라미터가 잘 들어오는지 확인만 하고, 해당 파라미터를 그대로 리턴하도록 했습니다.

```java
@ReadOperation
public String getPathVariable(@Selector String path1) {
    log.info("path1: {}", path1);
return path1;
}

```

/actuator/myLibraryInfo 하위에 myPathVar 라는 path 파라미터를 넣었습니다
- 응답에 myPathVar 라고 path 파라미터로 넣은 값이 잘 리턴되는걸 알 수 있습니다.
- "http://127.0.0.1:8080/actuator/myLibraryInfo/aaaa"




다중 path
- /actuator/myLibraryInfo/path1/path2/path3  와 같이 path가 여러개일때도 처리가 가능
- Selector 어노테이션을 내부를 보면 아래처럼 match 라는 필드가 있으며, 해당 필드는 SINGLE, ALL_REMAINING 중 하나를 넣을 수 있습니다. 
- 하이라이트한 부분을 읽어보면 알 수 있듯이 모든 path 부분을 캡쳐하고, path 구분을 위해 String[] 형태로 변환된다고 적혀있습니다.

- @Selector 의 match 기본값이 Match.SINGLE 이므로 아래처럼 파라미터 부분을 변경해주면 됩니다.

```java
@ReadOperation
public String getMultiPathVariable(@Selector(match = Selector.Match.ALL_REMAINING) String[] path) {
    log.info("path: {}", Arrays.asList(path));
return Arrays.asList(path).toString();
}
```
- path1/path2/path3.... 처럼 path를 여러개 넣어서 테스트해보니 입력받은 path 파라미터가 잘 수신되는걸 알 수 있습니다.


주의할 부분은 
- ALL_REMAINING 과 SINGLE 를 사용한 메서드를 각각 생성해 버리면,  
- path 갯수에 상관없이 ALL_REMAINING 메서드만 호출
- 어느 메서드가 호출되는지 애매하고 외우기도 어려우니 Endpoint 당 @Selector 는 한개만 사용

#### web , jmx 선택
@Endpoint는 web 과 jmx 둘다 지원해주는 endpoint
- 만약 web 용으로만 endpoint 를 만들고 싶다면 @WebEndpoint 를 이용
- 오직 HTTP 에만 노출되게 해줍니다.
  ```java
  @Target({ElementType.TYPE})
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Endpoint
  @FilteredEndpoint(WebEndpointFilter.class)
  public @interface WebEndpoint {
      @AliasFor(
          annotation = Endpoint.class
      )
      String id();
  
      @AliasFor(
          annotation = Endpoint.class
      )
      boolean enableByDefault() default true;
  }
  ```
jmx 용으로만 endpoint 를 만들고 싶다면 당연히 @JmxEndpoint 를 이용하면 됩니다.
- 종적으로 노출되는건 yml 에서 exposure.include 에 적힌 endpoint 가 외부로 노출
- 모든 조건이 만족되어야 외부로 노출됩니다.

#### rest controller 와 다를게 없음
endpoint 들은 
- @RestController 어노테이션을 이용해서 우리가 자주 만들던 rest controller 와 다를게 없습
- url 에 맞게 메서드 매핑을 해주고 json을 리턴하면 되니까요

공식가이드에서도 @RestControllerEndpoint 라는 어노테이션을 이용하면 일반적인 rest controller 구현하듯이 @GetMapping , @PostMapping 등을 써서 endpoint 를 만들수 있다고 합
- 다만 호환성을 위한 비용이 발생할 수 있으니 특별한 이유가 아니면 @EndPoint 나 @WebEndpoint 를 이용해서 구현하라고 권장

- DispatcherServlet -> controller 순으로 http 요청이 흘러가니 controller 앞단인 서블릿으로도 구현할 수 있지 않을까? 생각할 수 있습니다.

- @ServletEndpoint 를 이용해서 구현할 수 있으나 동일하게 호환성을 위한 비용이 발생할 수 있으니 가급적 @Endpoint 를 이용하라고 권장하고 있습니다.

- 권장하는 방법이 아니므로 저도 위 방법대로 해본적이 없고 굳이 예제로 제공할 필요도 없어보입니다.



#### 마무리

"결국 rest controller 를 만들면 되는거니 굳이 actuator 가 아닌 직접 rest controller 만들면 되지 않나? " 라고 생각할 수도 있습니다. 
- 그러나 직접 rest controller 로 만들어버리면, prometheus 와 같은  actuator 와 호환이 되는 여러 라이브러리와 연동이 될수 없습
- actuator 가 일종의 인터페이스 역할이므로 다른 라이브러리와의 연동을 위해 actuator 를 이용하는게 좋습니다.



custom endpoint 관련 전체 소스코드
- https://github.com/ChunGeun-Yu/spring-actuator-study/tree/customEndpoint





다음에는 actuator가 제공하는 endpoint 중 health endpoint 에 대해 알아보겠습니다.



아~ 이제 머리가 좀 아프네. 쉬었다 하자... 라고 생각하고 있나요? 이러면 결국 안본다는거 잘 알잖아요. 화이팅!

### 5. about health endpoint

actuator 에서 기본 제공하는 endpoint 중 모니터링 시스템과 자주 연동될 endpoint 로 health endpoint
- application의 health 정보를 제공합니다.

#### default health endpoint
application.yml 에 아래 설정만  한 상태에서 spring boot 를 구동해봅시다.

```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
```

```text
http://127.0.0.1:8080/actuator/health

{"status":"UP"}
```
- application이 구동중이라는 의미의 status: UP

#### show-components , show-details
눈에 띄는게 show-components 와 show-details 필드입니다. 우선 show-components: ALWAYS 로 설정 후 spring boot 재구동해봅시다.

```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    health:
      show-components: ALWAYS
```

show-components 설정을 했더니 아래처럼 components 필드에 disk 와 ping 의 health 상태가 추가
```text
{
  "status": "UP",
  "components": {
    "diskSpace": {
      "status": "UP"
    },
    "ping": {
      "status": "UP"
    }
  }
}
```


show-components 대신에 show-details 설정을 아래와 같이 해보겠습니다.
```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    health:
      show-details: ALWAYS
```

다시 health endpoint 를 확인해보면 아래처럼 components 내의 diskSpace 항목에 details 항목이 추가되었고 total, free 등의 상세 정보가 더 보입니다.
- show-details 는 details 필드에 상세 정보를 보여주는 설정입니다.
```text
{
  "status": "UP",
  "components": {
    "diskSpace": {
      "status": "UP",
      "details": {
        "total": 1572863995904,
        "free": 146222624768,
        "threshold": 10485760,
        "path": "D:\\2023-CKA-workspace\\SpringActuator\\spring-actuator-study\\.",
        "exists": true
      }
    },
    "ping": {
      "status": "UP"
    }
  }
}
```

#### 기본 제공해주는 health 정보들
spring boot는 auto configuration에 의해 아래와 같이 많은 health 정보들을 기본 제공해주고 있습니다. (너무 많아서 화면 캡쳐는 앞부분만 했습니다. )

그런데 위 예제에서는 diskspace 와 ping 밖에 안보여지는 이유는 cassandra, couchbase 등을 사용하지 않으니 health 정보를 보여줄게 없기 때문입니다.


https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.health.auto-configured-health-indicators
기본 제공되는 health 정보가 활성화 되기 위한 조건
DB health 정보가 보이기 위해서는 DB를 사용해야 합니다. 그래서 간단히 아래처럼 Database 설정을 해보겠습니다.

pom.xml 에 아래처럼 h2 DB 및 JPA 의존성을 넣어줍니다.

DB관련 의존성만 넣으면 되는것이니 mysql, oracle 의존성을 넣어도 되며, JPA 대신 mybatis 를 넣어도 됩니다.

<dependency>
	<groupId>com.h2database</groupId>
	<artifactId>h2</artifactId>
	<scope>runtime</scope>
</dependency>

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
이걸로 끝입니다. spring boot auto configuration에 의해 h2 DB와 연결됩니다. 즉 application 이 DB와 연결이 되었습니다.

이제 다시 health endpoint 를 확인해보면 아래처럼 db 라는 필드가 보이고 상세정보에 H2 DB 라는 정보가 보입니다.


만약 redis, mongo 등의 다른 Database 를 추가로 연결해서 사용한다면 redis, mongo 등의 health 정보도 함께 보이게 됩니다.



about HealthIndicator , custom HealthIndicator 만들기
아래와 같이 spring boot 에서는 기본 제공해주는 health 정보들이 많이 있습니다.

아래 파란색 부분은 health 정보 제공하는 실제 클래스명입니다.


https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.health.auto-configured-health-indicators
아래처럼 기본 제공되는 클래스중 하나인 DataSourceHealthIndicator 의 내부구조를 살펴보겠습니다.

상속을 하고 있어 다소 복잡해보이나 결국 HealthIndicator 라는 인터페이스를 구현한 클래스입니다.


HealthIndicator 인터페이스의 중요한 부분만 발췌하면 아래와 같습니다.

health() 라는 메서드를 각자 구현해야 하고, getHealth()  메서드는 details 정보를 응답에 포함할지 여부만 제공하는 default 메서드 입니다.

public interface HealthIndicator extends HealthContributor {

	default Health getHealth(boolean includeDetails) {
		Health health = health();
		return includeDetails ? health : health.withoutDetails();  <-- details 정보 포함여부 기능 제공
	}

	Health health();  <-- 여길 각 클래스에서 구현해야함.
}
아래처럼 나만의 custom health indicator 를 구현해봤습니다.

학습용도이니 단순히 현재 시간을 기준으로 up ,down 을 판단하고 그에 맞게 detail 정보를 다르게 설정해서 리턴하도록 만들었습니다.

실무에서는 application이 정상 구동되기 위해 필요로 하는(=의존하는) 서비스와 잘 연결되어 있는지를 구현하고 UP, DOWN 을 리턴하도록 하면 됩니다.



withDetail() 메서드에 key, value를 넣어주면, 응답 json 의 detail 필드에 key, value 가 들어가는 것만 기억해주세요. Health 클래스가 상당히 직관적으로 만들어져 있어서 별도 주석이 없어도 의미를 파악할 수 있어 보입니다.



@Component
public class MyCustomHealthIndicator implements HealthIndicator {
@Override
public Health health() {
boolean status = getStatus();
if ( status ) {
Health upHealth = Health.up()
.withDetail("key1", "value1")
.withDetail("key2", "value2")
.build();
return upHealth;
}
Health downHealth = Health.down()
.withDetail("key3", "value3")
.withDetail("key4", "value4")
.build();
return downHealth;
}

    boolean getStatus() {
        // 현재시각이 짝수,홀수인지에 따라 up, down을 판단하는 것으로 대체
        if ( System.currentTimeMillis() % 2 == 0 )
            return true;
        return false;
    }
}
이제 spring boot 재구동한 후 health endpoint 를 확인해봅시다.

아래처럼 myCustom 이라는 필드가 추가되었으며, 랜덤하게 up, down 으로 상태가 바뀝니다.

최상단의 status 는 모든 components 의 status가 모두 UP 일때만 UP 으로 표시됩니다.

그래서 myCustom 이 종종 DOWN  으로 표시될때, 최상단의 status 도 DOWN 으로 표시되게 됩니다.


클래스명을 MyCustomHealthIndicator 라고 만들었기에 HealthIndicator 를 제외한 앞쪽 부분이 json에 표시된다고 공식가이드에 적혀있습니다.

The identifier for a given HealthIndicator  is the name of the bean without the HealthIndicator  suffix, if it exists. In the preceding example, the health information is available in an entry named my.
< 출처: https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.health.writing-custom-health-indicators >





MyCustomHealthIndicator 클래스에 @Component 를 붙여놓았기에 무조건 bean 으로 등록이 됩니다. 만약 특정 상황일때만 bean 으로 등록하고 싶다면 어떻게 해야할까요?

위에서 살펴봤듯이 db, redis, mongo 등의 healthIndicator 들은 application이 해당 서비스를 실제로 사용할때만 json 에 health 정보가 보였습니다. 어떻게 이런 동작이 가능한 걸까요?



spring boot 에서 어떻게 구현했는지 코드를 확인하면 될듯 합니다.

위에서 살펴봤던 DataSourceHealthIndicator 클래스를 통해 spring boot 구현 방법을 알아보겠습니다.



우리가 알고 싶은건 DataSourceHealthIndicator 클래스에 @Component 어노테이션이 없는데 어떻게 bean 이 되었는가? 입니다.

아래처럼 DataSourceHealthIndicator  의 생성자에 디버그 포인트를 모두 걸어주고 디버그 모드로 구동을 해줍니다. spring boot 구동시점에 DataSourceHealthIndicator  bean이 생성되며, 좌측 하단의 call stack 을 통해 어떤 클래스에서 DataSourceHealthIndicator 의 생성자를 호출했는지 알수 있습니다.




auto configuration에 대해 잘 알고 있는 분이라면 미리 짐작할 수 있었을듯 한데

spring-boot-actuator-autoconfigure 의 DataSourceHealthContributorAutoConfiguration 클래스에서 생성자를 호출해주고 있었습니다. 무조건 생성자를 호출해주는게 아닌 아래와 같이 클래스 위쪽에 @ConditionalOnXXX 부분을 통해 특정 클래스파일이 있어야 하고 특정 bean이 존재해야 하며, db 라는 health indicator 가 enable 되어 있어야 하는 조건이 설정된걸 알 수있습니다.

@AutoConfiguration(after = DataSourceAutoConfiguration.class)
@ConditionalOnClass({ JdbcTemplate.class, AbstractRoutingDataSource.class })
@ConditionalOnBean(DataSource.class)
@ConditionalOnEnabledHealthIndicator("db")
@EnableConfigurationProperties(DataSourceHealthIndicatorProperties.class)
public class DataSourceHealthContributorAutoConfiguration implements InitializingBean {
(생략)
}
위와 같이 AutoConfiguration 관련 클래스에서 컨디션을 체크한 후 모두 만족되면 그때 HealthIndicator 관련 클래스들을 bean으로 등록해주는 겁니다.



@ConditionalOnXXX 어노테이션이 익숙하지 않은 분들은 아래 공식 가이드를 참고해주세요.

https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration.condition-annotations.class-conditions



status 종류
이제까지는 status: UP 혹은 status: DOWN 만 다루어 봤습니다.

그외에는 아래처럼 몇가지 상태 값이 더 있으며 각 상태별로 http response status 값도 알 수 있습니다.상태값을 추가하거나 http response status 값을 굳이(!) 변경하고 싶다면 아래 그림의 링크에 자세히 나와있으니 참고하세요. 개인적인 의견으로는 특별한 이유가 없다면 http response status 는 default 값을 써야 서로가 편하지 않을까 싶습니다. 공부할것도 많은데 사내에서만 적용되는 코딩 규칙이 너무 많아지면 힘드니까요.


https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.health.writing-custom-health-indicators


실제 코드에서도 아래처럼 Health. 을 누르면 up, down, outOfService, unknown 이 나오기에 위 상태값을 굳이 외울 이유는 없어보입니다.




이번 포스팅에서 사용된 소스코드는 아래 링크에 있습니다.

https://github.com/ChunGeun-Yu/spring-actuator-study/tree/healthEndpoint





본 포스팅은 health endpoint 공식 가이드를 기반으로 작성되었습니다. 좀 더 확실하게 알고 싶다면 아래 링크를 정독하면 됩니다.  https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.health

다음 포스팅에서는 info endpoint에 대해 알아보겠습니다. 내용이 어렵지 않습니다. 정주행 합시다~